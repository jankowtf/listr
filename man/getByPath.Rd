% Generated by roxygen2 (4.0.2): do not edit by hand
\name{getByPath}
\alias{getByPath}
\title{Get By Path (generic)}
\usage{
getByPath(input, value, outer = FALSE, resolve = FALSE, strict = c(0, 1,
  2), ...)
}
\arguments{
\item{input}{\strong{Signature argument}.
Object containing structure information.}

\item{value}{\code{\link{character}}.
Path as found in return value of \link[listr]{getStructure}.}

\item{outer}{\code{\link{logical}}.
\code{TRUE}: use \code{oindex} instead of \code{index} to retrieve the
  outer element values (i.e., outer list structure is preserved);
\code{FALSE}: use \code{index} to retrieve the inner element values
  (i.e. outer list structure is not preserved).}

\item{resolve}{\code{\link{logical}}.
\code{TRUE}: resolve path to basename component as names for return value;
\code{FALSE}: use path as names for return value.}

\item{strict}{\code{\link{numeric}}.
\itemize{
  \item{\code{0}: } {ignore without warning}
  \item{\code{1}: } {ignore with Warning}
  \item{\code{2}: } {stop with error}
}}

\item{...}{Further arguments to be passed to subsequent functions/methods.}
}
\description{
Retrieves actual values based on their \code{path}.
}
\examples{
\dontrun{

input <- list(
  x1 = list(x11 = list(x111 = 1, x112 = 1), x12 = list(x121 = 1, x122 = 1)),
  x2 = list(x21 = "x21"),
  x3 = list("x31"),
  x4 = "x4",
  x5 = list(1:3),
  list(list(1, 2), list(3, 4)),
  list(1:3),
  "char 1",
  "char 2",
  letters[1:3],
  c(1,3,5),
  TRUE,
  new.env(),
  data.frame(x = 1:3, y = 1:3)
)

## Inspect structure //
(struc <- getStructure(input))

## Name-based path //
getByPath(input, value = "x1")

getByPath(input, value = "x1/x11")
getByPath(input, value = "x1/x11", resolve = TRUE)
getByPath(input, value = "x1/x11", resolve = TRUE, resolve_by = "ppath")

getByPath(input, value = "x2/x21")
getByPath(input, value = "x2/x21", resolve = TRUE)
getByPath(input, value = "x2/x21", resolve = TRUE, resolve_by = "index")

## Position-based path //
getByPath(input, value = "6/1")
getByPath(input, value = "6/1", resolve = TRUE)
getByPath(input, value = "6/1", resolve = TRUE, resolve_by = "ppath")

## Multiple //
getByPath(input, value = c("x1/x11", "x2/x21"))
getByPath(input, value = c("x1/x11", "x2/x21"), resolve = TRUE)
getByPath(input, value = c("x1/x11", "x2/x21"), resolve = TRUE, resolve_by = "ppath")

getByPath(input, value = c("x1/x11", "x2/x21", "6/1"))
getByPath(input, value = c("x1/x11", "x2/x21", "6/1"), resolve = TRUE)
getByPath(input, value = c("x1/x11", "x2/x21", "6/1"), resolve = TRUE, 
  resolve_by = "index")

## Condition handling //
getByPath(input, value = "x1/99")
try(getByPath(input, value = "x1/99", strict = 1))
try(getByPath(input, value = "x1/99", strict = 2))

}
}
\author{
Janko Thyson \email{janko.thyson@rappster.de}
}
\references{
\url{http://github.com/rappster/listr}
}
\seealso{
\code{
  	\link[listr]{getByPath-list-method},
    \link[listr]{getStructure}
}
}

